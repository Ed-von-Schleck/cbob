<!DOCTYPE html><html lang="en"><head><title>cbob/build</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="cbob/build"><meta name="groc-project-path" content="cbob/build.py"><meta name="groc-github-url" content="https://github.com/Ed-von-Schleck/cbob"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/Ed-von-Schleck/cbob/blob/master/cbob/build.py">cbob/build.py</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">cbob.pathhelpers</span> <span class="kn">as</span> <span class="nn">pathhelpers</span>
<span class="kn">import</span> <span class="nn">cbob.checks</span> <span class="kn">as</span> <span class="nn">checks</span>

<span class="k">class</span> <span class="nc">_Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Our dependency graph for the source files is composed of these Nodes. They are used
to implement a directed acyclical graph (DAG) of file dependencies.
Whe use <strong>slots</strong> instead of the standard <strong>dict</strong> because there might be many files
and we want to save some memory here.</p></div></div><div class="code"><div class="wrapper">    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;file_path&quot;</span><span class="p">,</span> <span class="s">&quot;target_name&quot;</span><span class="p">,</span> <span class="s">&quot;dependencies&quot;</span><span class="p">,</span> <span class="s">&quot;last_dep_change&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">target_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span> <span class="o">=</span> <span class="n">file_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_name</span> <span class="o">=</span> <span class="n">target_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_dep_change</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">mark_dirty_recursively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirty_sources</span><span class="p">,</span> <span class="n">dirty_headers</span><span class="p">,</span> <span class="n">object_mtime</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">is_source</span> <span class="o">=</span> <span class="n">object_mtime</span> <span class="ow">is</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">is_source</span><span class="p">:</span>
            <span class="n">object_file_path</span> <span class="o">=</span> <span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_object_file_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)</span>
            <span class="n">object_mtime</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="n">object_file_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">object_file_path</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>

            <span class="n">precompiled_header_path</span> <span class="o">=</span> <span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_precompiled_header_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)</span>
            <span class="n">precompiled_header_mtime</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="n">precompiled_header_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">precompiled_header_path</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We need to check the headers even if the source is dirty, because we might need to
re-precompile the headers too. To make sure the loop enters, we query the <code>mtime</code> of the source after
the recursive walk over the headers returns. If this node is <em>not</em> the source, but a header, we <em>do</em>
get the <code>mtime</code>. However, if that property has already been set by a previous walk, we take that instead.</p></div></div><div class="code"><div class="wrapper">        <span class="bp">self</span><span class="o">.</span><span class="n">last_dep_change</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">is_source</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_dep_change</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_dep_change</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>The walk itself is destructive, so that every dependency is only visited once <em>ever</em>. This makes this algorithm
O(N). Chances are, however, that not all nodes have to be visited, because we return as soon as one header (or
it's dependencies) is newer than the corresponding object file.</p></div></div><div class="code"><div class="wrapper">        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_dep_change</span> <span class="o">&lt;=</span> <span class="n">object_mtime</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">node_last_dep_change</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">mark_dirty_recursively</span><span class="p">(</span><span class="n">dirty_sources</span><span class="p">,</span> <span class="n">dirty_headers</span><span class="p">,</span> <span class="n">object_mtime</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_dep_change</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">node_last_dep_change</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_dep_change</span><span class="p">)</span>
        </div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>When we are back at the start, we first look if the source needs to be recompiled. Only then we consider recompiling
the headers, too.</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="n">is_source</span><span class="p">:</span>
            <span class="n">last_change</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_dep_change</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">last_change</span> <span class="o">&gt;</span> <span class="n">object_mtime</span><span class="p">:</span>
                <span class="n">dirty_sources</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_dep_change</span> <span class="o">&gt;</span> <span class="n">precompiled_header_mtime</span><span class="p">:</span>
                    <span class="n">uncompiled_header_path</span> <span class="o">=</span> <span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_uncompiled_header_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)</span>
                    <span class="n">dirty_headers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">uncompiled_header_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_dep_change</span> <span class="o">=</span> <span class="n">last_change</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_dep_change</span>


<span class="k">def</span> <span class="nf">_compile</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">compiler_path</span><span class="p">,</span> <span class="n">target_name</span><span class="p">,</span> <span class="n">c_switch</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">get_output_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">include_pch</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>This function is later used as a partial (curried) function, with the <code>file_path</code> parameter being mapped
to a list of files to compile.</p></div></div><div class="code"><div class="wrapper">    <span class="k">print</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="n">compiler_path</span><span class="p">,</span> <span class="n">file_path</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">get_output_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">cmd</span> <span class="o">+=</span> <span class="p">[</span><span class="s">&quot;-o&quot;</span><span class="p">,</span> <span class="n">get_output_path</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">c_switch</span><span class="p">:</span>
        <span class="n">cmd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;-c&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_pch</span><span class="p">:</span>
        <span class="n">cmd</span> <span class="o">+=</span> <span class="p">[</span><span class="s">&quot;-fpch-preprocess&quot;</span><span class="p">,</span> <span class="s">&quot;-include&quot;</span><span class="p">,</span> <span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_uncompiled_header_path</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)]</span>

    <span class="n">process</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_get_dep_info</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>The options used:
* -H: prints the dotted header information
* -w: suppressed warnings
* -E: makes GCC stop after the preprocessing (no compilation)
* -P: removes comments</p></div></div><div class="code"><div class="wrapper">    <span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_gcc_path</span><span class="p">(),</span> <span class="s">&quot;-H&quot;</span><span class="p">,</span> <span class="s">&quot;-w&quot;</span><span class="p">,</span> <span class="s">&quot;-E&quot;</span><span class="p">,</span> <span class="s">&quot;-P&quot;</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>For some reason gcc outputs the header information over <code>stderr</code>.
Not that this is documented anywhere ...</p></div></div><div class="code"><div class="wrapper">    <span class="k">with</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">process</span><span class="p">:</span>
        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>The output looks like
    . inc1.h
    .. inc1inc1.h
    . inc2.h
etc., with inc1inc1.h being included by inc1.h. In other words, the number of dots
indicates the level of nesting. Also, there are lots of lines of no interest to us.
Let's ignore them.</p></div></div><div class="code"><div class="wrapper">    <span class="n">raw_deps</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">err</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">line</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>
    <span class="n">deps</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">dots</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">rest</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">dots</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">in</span> <span class="n">raw_deps</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">deps</span>

<span class="nd">@checks.requires_target_exists</span>
<span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">jobs</span><span class="p">):</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Let's build a target! But before that, process all target dependencies
recursively to make sure they are up to date.</p></div></div><div class="code"><div class="wrapper">    <span class="n">dependencies_dir</span> <span class="o">=</span> <span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_dependencies_dir</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">dependencies_dir</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Building dependency &#39;{}&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dep</span><span class="p">))</span>
        <span class="n">build</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span> <span class="n">jobs</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Done building dependency &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dep</span><span class="p">))</span>
        <span class="k">print</span><span class="p">()</span>
    <span class="n">build_target</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">jobs</span><span class="p">)</span>

<span class="nd">@checks.requires_target_exists</span>
<span class="k">def</span> <span class="nf">build_target</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">jobs</span><span class="p">):</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Bail out if there are no sources -
there is no need for a virtual target to be fully configured.</p></div></div><div class="code"><div class="wrapper">    <span class="n">sources_links</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_sources_dir</span><span class="p">(</span><span class="n">target_name</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">sources_links</span><span class="p">:</span>
        <span class="n">_do_build_target</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">jobs</span><span class="p">,</span> <span class="n">sources_links</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;No sources - nothing to do.&quot;</span><span class="p">)</span>

<span class="nd">@checks.requires_configured</span>
<span class="k">def</span> <span class="nf">_do_build_target</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">jobs</span><span class="p">,</span> <span class="n">sources_links</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Here the actual heavy lifting happens.
First off, if a <code>jobs</code> parameter is given, it's passed on from the argument parser as a list.
We take the first element of it. If its <code>None</code>, then <code>multiprocessing.Pool</code> will use as many
processes as there are CPUs.</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span> <span class="n">jobs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">jobs</span> <span class="o">=</span> <span class="n">jobs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sources_dir</span> <span class="o">=</span> <span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_sources_dir</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
    <span class="n">compiler_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">readlink</span><span class="p">(</span><span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_compiler_symlink</span><span class="p">(</span><span class="n">target_name</span><span class="p">))</span>
    <span class="n">linker_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">readlink</span><span class="p">(</span><span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_linker_symlink</span><span class="p">(</span><span class="n">target_name</span><span class="p">))</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">jobs</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>The <code>sources_list</code> parameter is just so that we don't have to touch the <code>sources</code> directory twice, if we
have listed its content before.</p></div></div><div class="code"><div class="wrapper">    <span class="k">print</span><span class="p">(</span><span class="s">&quot;calculating dependencies ...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">&quot; &quot;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">sources_links</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_source_path_from_symlink</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources_links</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_source_path_from_symlink</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">sources_dir</span><span class="p">)]</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We have two indexes: The <code>source_node_index</code> points, well, to the source nodes, while the <code>node_index</code> points to
all nodes. Later we use the nodes in the <code>source_node_index</code> as root nodes for starting the search for dirty nodes.</p></div></div><div class="code"><div class="wrapper">    <span class="n">source_node_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">file_path</span><span class="p">:</span> <span class="n">_Node</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">target_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">file_path</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">}</span>
    <span class="n">node_index</span> <span class="o">=</span> <span class="n">source_node_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>This is somewhat straight-forward if you have ever written a stream-parser (like SAX), though it adds a twist
in that we save references to processed nodes in a set. It may be a bit unintuitive that we only skip a node 
if it was in another node's dependencies - but note how, when we process a node, we don't add an edge to that
very node, but to the node one layer <em>down</em> in the stack. Think about it for a while, then it makes sense.</p></div></div><div class="code"><div class="wrapper">    <span class="n">processed_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">deps</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">_get_dep_info</span><span class="p">,</span> <span class="n">sources</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">source_node_index</span><span class="p">[</span><span class="n">file_path</span><span class="p">]</span>
        <span class="n">parent_nodes_stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>

        <span class="n">includes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">current_depth</span><span class="p">,</span> <span class="n">dep_path</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
            <span class="n">includes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;#include </span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">dep_path</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dep_path</span> <span class="ow">in</span> <span class="n">node_index</span><span class="p">:</span>
                <span class="n">current_node</span> <span class="o">=</span> <span class="n">node_index</span><span class="p">[</span><span class="n">dep_path</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">current_node</span> <span class="ow">in</span> <span class="n">processed_nodes</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">processed_nodes</span> <span class="o">|=</span> <span class="n">current_node</span><span class="o">.</span><span class="n">dependencies</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_node</span> <span class="o">=</span> <span class="n">_Node</span><span class="p">(</span><span class="n">dep_path</span><span class="p">,</span> <span class="n">target_name</span><span class="p">)</span>
                <span class="n">node_index</span><span class="p">[</span><span class="n">dep_path</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_node</span>

            <span class="n">parent_nodes_stack</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">parent_nodes_stack</span><span class="p">[:</span><span class="n">current_depth</span><span class="p">]</span>
            <span class="n">parent_nodes_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dependencies</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">current_node</span><span class="p">)</span>
            <span class="n">parent_nodes_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_node</span><span class="p">)</span>
        <span class="n">processed_nodes</span> <span class="o">|=</span> <span class="n">node</span><span class="o">.</span><span class="n">dependencies</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>For every source file, we generate a corresponding <code>.h</code> file that consists of all the
<code>#include</code>s of that source file. This is the <code>uncompiled_header</code>. It is saved in one
of <em>cbob</em>s mysterious directories. After we processed a source file, we check if it is
up to date. We are doing that with a set comparison, because we are interested in <em>semantic</em>,
not byte-for-byte equality (if that turns out to be overly slow, it can be replaced with
a line-by-line comparison with a list).</p></div></div><div class="code"><div class="wrapper">        <span class="n">uncompiled_header_path</span> <span class="o">=</span> <span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_uncompiled_header_path</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">uncompiled_header_path</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">uncompiled_header</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">includes</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">uncompiled_header</span><span class="p">):</span>
                    <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>It the uncompiled header file changed, we save it and delete any existing precompiled header.</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">uncompiled_header_path</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">uncompiled_header</span><span class="p">:</span>
                <span class="n">uncompiled_header</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">includes</span><span class="p">)</span>
                
            <span class="n">precompiled_header_path</span> <span class="o">=</span> <span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_precompiled_header_path</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">precompiled_header_path</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">pass</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;done.&quot;</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s">&quot;determining files for recompilation ...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">&quot; &quot;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="n">dirty_sources</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">dirty_headers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">source_node</span> <span class="ow">in</span> <span class="n">source_node_index</span><span class="o">.</span><span class="n">values</span><span class="p">():</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>This starts a depth-first recursive search for dirty (changed) source and header files.
See the function comments for explanation.</p></div></div><div class="code"><div class="wrapper">        <span class="n">source_node</span><span class="o">.</span><span class="n">mark_dirty_recursively</span><span class="p">(</span><span class="n">dirty_sources</span><span class="p">,</span> <span class="n">dirty_headers</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;done.&quot;</span><span class="p">)</span>

    <span class="c">#TODO: Sort dirty_sources for compile time (longest first).</span>

    <span class="k">if</span> <span class="n">dirty_sources</span><span class="p">:</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>precompile headers</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="n">dirty_headers</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;precompiling headers ...&quot;</span><span class="p">)</span>
            <span class="n">compile_func</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                    <span class="n">_compile</span><span class="p">,</span>
                    <span class="n">compiler_path</span><span class="o">=</span><span class="n">compiler_path</span><span class="p">,</span>
                    <span class="n">target_name</span><span class="o">=</span><span class="n">target_name</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">compile_func</span><span class="p">,</span> <span class="n">dirty_headers</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">exit</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;done.&quot;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>compile sources</p></div></div><div class="code"><div class="wrapper">        <span class="k">print</span><span class="p">(</span><span class="s">&quot;compiling sources ...&quot;</span><span class="p">)</span>
        <span class="n">compile_func</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="n">_compile</span><span class="p">,</span>
                <span class="n">compiler_path</span><span class="o">=</span><span class="n">compiler_path</span><span class="p">,</span>
                <span class="n">target_name</span><span class="o">=</span><span class="n">target_name</span><span class="p">,</span>
                <span class="n">get_output_path</span><span class="o">=</span><span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_object_file_path</span><span class="p">,</span>
                <span class="n">c_switch</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                <span class="n">include_pch</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">compile_func</span><span class="p">,</span> <span class="n">dirty_sources</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">exit</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;done.&quot;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>link</p></div></div><div class="code"><div class="wrapper">        <span class="n">object_file_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_object_file_path</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span> <span class="k">for</span> <span class="n">file_path</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">]</span>
        <span class="n">bin_path</span> <span class="o">=</span> <span class="n">pathhelpers</span><span class="o">.</span><span class="n">get_bin_path</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="n">linker_path</span><span class="p">,</span> <span class="s">&quot;-o&quot;</span><span class="p">,</span> <span class="n">bin_path</span><span class="p">]</span> <span class="o">+</span> <span class="n">object_file_names</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;linking ...&quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span> <span class="n">bin_path</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">return_code</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">(</span><span class="n">return_code</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;done.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Nothing to do.&quot;</span><span class="p">)</span></div></div></div></div></body></html>