<!DOCTYPE html><html lang="en"><head><title>index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="index"><meta name="groc-project-path" content="README.md"><meta name="groc-github-url" content="https://github.com/Ed-von-Schleck/cbob"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/Ed-von-Schleck/cbob/blob/master/README.md">README.md</a></div></div><div id="document"><div class="segment"><div class="comments"><div class="wrapper"><h1 id="cbob">cbob</h1>

<p><em>cbob</em> builds your C/C++ projects. It does automatic dependency resolution (well, with the help of gcc, but still) of your source files. Contrary to most build tools out there, it does <em>not</em> need configuration files - you use it solely over the CLI (it might grow a GUI at some time). <em>cbob</em> tries to do as little magic as possible, prefers explicicity over implicity and ease of use over being the most generic tool out there.</p>

<p><em>cbob</em> is far from complete at the moment, but here's what works:</p>

<h2 id="usage">Usage</h2>

<h3 id="help">Help</h3>

<p>Do</p>

<pre><code class="bash">cbob --help
</code></pre>

<p>to get a list overview over the possible commands. To get help for a specific command, do</p>

<pre><code class="bash">cbob &lt;command&gt; --help
</code></pre>

<h3 id="commands">Commands</h3>

<h4 id="init-cbob">Init cbob</h4>

<p>In your project's root directory, do</p>

<pre><code class="bash">cbob init
</code></pre>

<p>to initialize <em>cbob</em> for your project.</p>

<h4 id="create-a-new-target">Create a new target</h4>

<p>Every project needs at least one target to be defined. The name of the target is also the name of the resulting binary. To create a target, do</p>

<pre><code class="bash">cbob new &lt;target-name&gt;
</code></pre>

<h4 id="adding-a-file-to-a-target">Adding a file to a target</h4>

<p>Building a target means building all source files that have been added to it. You can use wildcards like <code>src/*.c</code>, but it will <em>not</em> magically add files you add to <code>src/</code> after that (it does not track the directory, only files). <em>cbob</em> does not accept non-standard file endings. There's no need to add header files or other dependencies. To add one or more files, do</p>

<pre><code class="bash">cbob add &lt;target-name&gt; &lt;path-to-source-file&gt; [&lt;path-to-other-source-file&gt; ...]
</code></pre>

<h4 id="configuring-a-target">Configuring a target</h4>

<p>At the very least, a compiler need to be chosen. There is more, though: Do <code>cbob configure --help</code> to get a list of all configuration options. To try and let cbob figure it all out for you, do</p>

<pre><code class="bash">cbob configure --auto &lt;target-name&gt;
</code></pre>

<h4 id="building-a-target">Building a target</h4>

<p>Simply do</p>

<pre><code class="bash">cbob build &lt;target-name&gt;
</code></pre>

<p>and you will end up with a binary in the directory you configured for your output (if you chose to auto-configure it's either <code>bin/</code> if it's there or the project's root). It will automatically use as many processes as there are cpus (or you can specify the number manually with <code>-j</code>/<code>--jobs</code>).</p>

<p>A more complete documentation will be written once all the planned features are in placed (until then, expect <em>cbob</em> to change a lot).</p>

<h2 id="features">Features</h2>

<p>Apart from the obvious, there's</p>

<ul>
<li>Automatic header dependency tracking: You don't need to declare your <code>include</code>s somewhere, <em>cbob</em> gets it right. DRY, you know.</li>
<li>Precompiled headers: By default, <em>cbob</em> precompiles your headers (and uses them) transparently.</li>
<li>Target dependencies: You can make a target dependend on other targets. When building a target, <em>cbob</em> first makes sure its dependencies are up to date. For example, you can make a <em>virtual</em> <code>all</code> target that depends on all other targets (which can have dependencies as well).</li>
</ul>

<h2 id="planned-features">Planned Features</h2>

<ul>
<li>Runners: Run code (shell files or binaries) before or after compiling (like for checks and tests).</li>
<li>Hash-based dependency-tracking: In addition to looking at <code>mtime</code>s of files, <em>cbob</em> will look at the SHA{256,512} hash value of a (preprocessed) source to determine if it has changed, or maybe changed back to a previously compiled object file that is still in the object file cache.</li>
<li>Options: Make it easy to define <code>--enable-foo</code> style configuration options.</li>
<li>Libtool support: Use libtool to make building libraries easier.</li>
<li>Plugins: Add features (or change how <em>cbob</em> works) by hooking custom Python code into <em>cbob</em>.</li>
<li>Documentation: Document everything thoroughly and write a tutorial.</li>
</ul>

<h2 id="maybe-features">Maybe-Features</h2>

<ul>
<li>Target overlays: A target that just overlays some option (e.g. exchanging <code>-Og</code> with <code>-O2</code> in the CFLAGS), but transparently follows its parent target's changes (e.g. think of a <code>release</code> overlay for the <code>development</code> target). So far, I haven't had an idea how to implement this elegantly.</li>
<li>Support for similar languages, e.g. D or Rust</li>
<li>Sub-projects: Let <em>cbob</em> handle projects in subdirectories (think of git submodules, and stuff like pre-checks as <em>cbob</em>-projects, hosted on github, as easily re-usable recipies).</li>
</ul>

<h2 id="non-features">Non-Features</h2>

<p>Things that are out of scope (though you may try to convince me otherwise):</p>

<ul>
<li>Support for every language out there (but maybe support for doing, say, Python-modules written in C).</li>
<li>Support for system-wide installation (though I like <em>cbob</em> to be able to play nice with make/autotools).</li>
</ul>

<h2 id="feedback">Feedback</h2>

<p>As you obviously just stumbled over this very new piece of software, I am very much interested in your opinion about it (try it - it ist usable? How is it better/worse than other tools? Is it fast enough? Is it documented enough? Can it do enough? Is it cool enough?). Just open an issue on github and drop a line or two there.</p>

<p>Better yet, contribute to it. It is written in Python (though in a style that lets me transition to C; I haven't made up my mind about it yet), so it's fun. I'll gladly take pull requests.</p></div></div></div></div></body></html>