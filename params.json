{"name":"cbob","tagline":"Building C/C++ Software Should Be Fun","body":"`cbob` builds your C/C++ projects. It does automatic dependency resolution (well, with the help of gcc, but still) of your source files. Contrary to most build tools out there, it does *not* need configuration files - you use it solely over the CLI (it might grow a GUI at some time). `cbob` tries to do as little magic as possible, prefers explicicity over implicity and ease of use over being the most generic tool out there.\r\n\r\n`cbob` is far from complete at the moment, but here's what works:\r\n\r\nUsage\r\n-----\r\n\r\n### Help ###\r\n\r\nDo\r\n```bash\r\ncbob --help\r\n```\r\nto get a list overview over the possible commands. To get help for a specific command, do\r\n```bash\r\ncbob <command> --help\r\n```\r\n\r\n### Commands ###\r\n\r\n#### Init cbob ####\r\n\r\nIn your project's root directory, do\r\n```bash\r\ncbob init\r\n```\r\nto initialize `cbob` for your project.\r\n\r\n#### Create a new target ####\r\n\r\nEvery project needs at least one target to be defined. The name of the target is also the name of the resulting binary. To create a target, do\r\n```bash\r\ncbob new <target-name>\r\n```\r\n\r\n#### Adding a file to a target ####\r\n\r\nBuilding a target means building all source files that are added to it. You can use wildcards like `src/*.c`, but it will *not* magically add files you add to `src/` after that (it does not track the directory, only files). `cbob` does not accept non-standard file endings. There's no need to add header files or other dependencies. To add one or more files, do\r\n```bash\r\ncbob add <target-name> <path-to-source-file> [<path-to-other-source-file> ...]\r\n```\r\n\r\n#### Configuring a target ####\r\n\r\nAt the very least, a compiler need to be chosen. There is more, though: Do `cbob configure --help` to get a list of all configuration options. To try and let cbob figure it all out for you, do\r\n```bash\r\ncbob configure --auto\r\n```\r\n\r\n#### Building a target ####\r\n\r\nSimply do\r\n```bash\r\ncbob build <target-name>\r\n```\r\nand you will end up with a binary in the directory you configured for your output (if you chose to auto-configure it's either `bin/` if it's there or the project's root).\r\n\r\nPlanned Features\r\n----------------\r\n\r\n* Target dependencies: Require other targets to be build and up-to-date (e.g. think of an `all` target that depends on all other targets).\r\n* Runners: Run code (shell files or binaries) before or after compiling (like for checks and tests).\r\n* Hash-based dependency-tracking: In addition to looking at `mtime`s of files, `cbob` will look at the SHA{256,512} hash value of a (preprocessed) source to determine if it has changed, or maybe changed back to a previously compiled object file that is still in the object file cache.\r\n* Options: Make it easy to define `--enable-foo` style configuration options.\r\n* Libtool support: Use libtool to make building libraries easier.\r\n\r\nMaybe-Features\r\n--------------\r\n\r\n* Target overlays: A target that just overlays some option (e.g. exchanging `-Og` with `-O2` in the CFLAGS), but transparently follows it's parent target's changes (e.g. think of a `release` overlay for the `development` target). So far, I haven't had an idea how to implement this elegantly.\r\n* Support for similar languages, e.g. D or Rust\r\n* Sub-projects: Let `cbob` handle projects in subdirectories (think of git submodules, and stuff like pre-checks as `cbob`-projects, hosted on github, as easily re-usable recipies).\r\n\r\nNon-Features\r\n------------\r\n\r\nThings that are out of scope (though you may try to convince me otherwise):\r\n* Support for every language out there (but maybe support for doing, say, Python-modules written in C).\r\n* Support for system-wide installation (though I like `cbob` to be able to play nice with make/autotools).\r\n\r\nHow it works\r\n------------\r\n\r\nJust look in your `.cbob` directory. Every target is a subdirectory of `.cbob/targets`. Every source file is a symlink in its `sources` subdirectory. The source's file path relative to the project root is mangled (`/` replaced with `_`) so that it is a flat list. Similarly, the configured compiler is just a symlink, and so on.\r\n\r\nWhen `cbob` builds a target, it first creates a bi-directional graph of dependencies by parsing gcc's output when invoked with `-M`. Files with dependencies (and a file has always a dependency on itself) older than the corresponding object file in `.cbob/build` are marked for recompilation, as well as all source files that depend (directly or indirectly) on our file in question (bi-directional, remember?).\r\n\r\nFeedback\r\n--------\r\n\r\nAs you obviously just stumbled over this very new piece of software, I am very much interested in your opinion about it (try it - it ist usable? How is it better/worse than other tools? Is it fast enough? Is it documented enough? Can it do enough? Is it cool enough?). Just open an issue on github and drop a line or two there.\r\n\r\nBetter yet, contribute to it. It is written in Python (though in a style that lets me transition to C; I haven't made up my mind about it yet), so it's fun. I'll gladly take pull requests.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}